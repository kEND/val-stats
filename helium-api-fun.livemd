# Helium API fun

## Section

```elixir
Mix.install([
  {:tesla, "~> 1.4"},
  {:jason, ">= 1.0.0"},
  {:vega_lite, "~> 0.1.0"},
  {:kino, "~> 0.3.0"}
])
```

```elixir
defmodule HeliumClient do
  require Tesla

  def client(url \\ "https://api.helium.io/") do
    Tesla.client([
      {Tesla.Middleware.BaseUrl, url},
      Tesla.Middleware.JSON
    ])
  end
end
```

```elixir
url = "https://api.helium.io"

slk = "114nxJxnwFXrPMnCMHir3ZxddpveGGwVAyKitPo293yFAB69DN2"
ups = "112J6SmH7LGKNLDyG6Wbqd9pmA2zAJbgNcmAwQZtYKYmNQunYd73"

{:ok, %{body: body}} = HeliumClient.client(url) |> Tesla.get("/v1/validators/" <> slk)
```

```elixir
%{"data" => %{"penalties" => penalties}} = body
penalties
```

```elixir
{:ok, %{body: body}} = HeliumClient.client(url) |> Tesla.get("/v1/validators/" <> ups)
```

#### UPS CGs of 8/25

> looks like 2 good CGs and then the third was the "last three"

* 3 solid CGs without perf penalties
* Netdata metrics look good
* 4th CG, we're in the **last three** validators via `hbbft perf`.
* 0/72 seen early in that CG for all three of the **last three**.
* perf penalties...

Posted a question/comment on discord #validators.  We'll see if anything comes of it.  Would `build-from-source` prevent this?  Would a better network?

`build-from-source` seems unlikely to have much influence given the correlation of the last three.  A better network could only help, but this also seems more of a bug related to position in CG.

* [ ] tracking the entire CG population throughout several CGs would be important to confirm this again.

##### after 3rd CG, a 0.2 perf, so network isn't great

```
    "penalties" => [
         %{"amount" => 0.099853515625, "height" => 975914, "type" => "performance"},
         %{"amount" => 0.19970703125, "height" => 981507, "type" => "performance"},
         %{"amount" => 0.858734130859375, "height" => 975548, "type" => "performance"},
         %{"amount" => 0.8588104248046875, "height" => 975614, "type" => "performance"},
         %{"amount" => 0.5, "height" => 975482, "type" => "tenure"},
         %{"amount" => 0.5, "height" => 975515, "type" => "tenure"},
         %{"amount" => 0.5, "height" => 975548, "type" => "tenure"},
         %{"amount" => 0.5, "height" => 975581, "type" => "tenure"},
         %{"amount" => 0.5, "height" => 975881, "type" => "tenure"},
         %{"amount" => 0.5, "height" => 981436, "type" => "tenure"},
         %{"amount" => 0.5, "height" => 981469, "type" => "tenure"},
         %{"amount" => 0.5, "height" => 981507, "type" => "tenure"}
       ],

```

<!-- livebook:{"break_markdown":true} -->

### now for rewards...

```elixir
query = [min_time: "2021-07-01T00:00:00.000000Z", max_time: "2021-08-31T00:00:00.000000Z"]

{:ok, %{body: body}} =
  HeliumClient.client(url) |> Tesla.get("/v1/validators/" <> slk <> "/rewards", query: query)

{:ok, %{body: body}} =
  HeliumClient.client(url)
  |> Tesla.get("/v1/validators/" <> slk <> "/rewards", query: [cursor: body["cursor"]])

slk_rewards = body["data"]
```

adjust the above to get rewards by month?

```elixir
# sort the rewards
slk_rewards = Enum.sort_by(slk_rewards, & &1["block"], :asc)
```

```elixir
query = [min_time: "2021-07-01T00:00:00.000000Z", max_time: "2021-08-31T00:00:00.000000Z"]

{:ok, %{body: body}} =
  HeliumClient.client(url) |> Tesla.get("/v1/validators/" <> ups <> "/rewards", query: query)

{:ok, %{body: body}} =
  HeliumClient.client(url)
  |> Tesla.get("/v1/validators/" <> ups <> "/rewards", query: [cursor: body["cursor"]])

ups_rewards = body["data"]
```

```elixir
# sort the rewards
ups_rewards = Enum.sort_by(ups_rewards, & &1["block"], :asc)
```

### Graphs?

```elixir
alias VegaLite, as: Vl
```

```elixir
block = 917_527

defmodule BlockPrice do
  alias HeliumClient
  @url "https://api.helium.io"
  def price(block) do
    {:ok, %{body: %{"data" => data}}} =
      HeliumClient.client(@url) |> Tesla.get("/v1/oracle/prices/" <> Integer.to_string(block))

    data["price"] / 100_000_000
  end
end

BlockPrice.price(block)
```

```elixir
slk_data =
  slk_rewards
  |> Enum.map(fn x ->
    %{
      "block" => x["block"],
      "amount" => x["amount"] / 100_000_000,
      "price" => BlockPrice.price(x["block"])
    }
  end)
```

```elixir
ups_data =
  ups_rewards
  |> Enum.map(fn x ->
    %{
      "block" => x["block"],
      "amount" => x["amount"] / 100_000_000,
      "price" => BlockPrice.price(x["block"])
    }
  end)
```

```elixir
Vl.new(width: 750, height: 400, title: "Sharp Leather Kangaroo HNT/USD")
|> Vl.data_from_values(slk_data)
|> Vl.encode_field(:x, "block")
|> Vl.layers([
  Vl.new()
  |> Vl.mark(:bar, color: "#6BC702")
  |> Vl.encode_field(:y, "amount", type: :quantitative, title: "HNT"),
  Vl.new()
  |> Vl.mark(:line)
  |> Vl.encode_field(:y, "price", type: :quantitative, title: "USD")
  |> Vl.encode(:size, value: 2)
])
|> Vl.resolve(:scale, y: :independent)
```

```elixir
Vl.new(width: 750, height: 400, title: "Uneven Peanut Swift HNT/USD")
|> Vl.data_from_values(ups_data)
|> Vl.encode_field(:x, "block")
|> Vl.layers([
  Vl.new()
  |> Vl.mark(:bar, color: "#6BC702")
  |> Vl.encode_field(:y, "amount", type: :quantitative, title: "HNT"),
  Vl.new()
  |> Vl.mark(:line)
  |> Vl.encode_field(:y, "price", type: :quantitative, title: "USD")
  |> Vl.encode(:size, value: 2)
])
|> Vl.resolve(:scale, y: :independent)
```

```elixir
slk_data =
  slk_rewards
  |> Enum.map(fn x ->
    %{
      "validator" => "kanga",
      "timestamp" => x["timestamp"],
      "amount" => x["amount"] / 100_000_000,
      "price" => BlockPrice.price(x["block"])
    }
  end)

Enum.reverse(slk_data) |> Enum.take(15) |> IO.inspect()
```

```elixir
ups_data =
  ups_rewards
  |> Enum.map(fn x ->
    %{
      "validator" => "swift",
      "timestamp" => x["timestamp"],
      "amount" => x["amount"] / 100_000_000,
      "price" => BlockPrice.price(x["block"])
    }
  end)

Enum.reverse(ups_data) |> Enum.take(15)
```

```elixir
val_data = slk_data ++ ups_data
```

```elixir
Vl.new(width: 740, height: 400, title: "Validator HNT/USD")
|> Vl.data_from_values(val_data)
|> Vl.encode_field(:x, "timestamp",
  type: :temporal,
  time_unit: [
    unit: "yearmonthdate",
    step: 1
  ],
  title: "Date"
)
|> Vl.layers([
  Vl.new()
  |> Vl.mark(:bar, color: "#6BC702", tooltip: true)
  |> Vl.encode_field(:y, "amount",
    type: :quantitative,
    aggregate: :sum,
    stack: "null",
    title: "HNT"
  )
  |> Vl.encode(:color,
    field: "validator",
    scale: [range: ["#675193", "#CA8861"]]
  )
  |> Vl.encode(:opacity, value: 0.6),
  Vl.new()
  |> Vl.mark(:line)
  |> Vl.encode_field(:y, "price",
    type: :quantitative,
    aggregate: :mean,
    title: "USD"
  )
  |> Vl.encode(:size, value: 2)
])
|> Vl.resolve(:scale, y: :independent)
```

### healthchecks.io

<p style="center">
  <a href="https://healthchecks.io/projects/50f6d1f2-d3db-49f0-87d7-a1b0619262e5/checks/"><img src="https://healthchecks.io/badge/de919987-3574-4da8-b3b2-56b43f/QUXmy6cJ-2/uneven-peanut-swift.svg" style="max-width: 100%;"></a>
  <a href="https://healthchecks.io/projects/50f6d1f2-d3db-49f0-87d7-a1b0619262e5/checks/"><img src="https://healthchecks.io/badge/de919987-3574-4da8-b3b2-56b43f/bMExPdvp-2/pbau-tertius.svg" style="max-width: 100%;"></a>
  <a href="https://healthchecks.io/projects/50f6d1f2-d3db-49f0-87d7-a1b0619262e5/checks/"><img src="https://healthchecks.io/badge/de919987-3574-4da8-b3b2-56b43f/dyKy9Pv0-2/sharp-leather-kangaroo.svg" style="max-width: 100%;"></a>
  <a href="https://healthchecks.io/projects/50f6d1f2-d3db-49f0-87d7-a1b0619262e5/checks/"><img src="https://healthchecks.io/badge/de919987-3574-4da8-b3b2-56b43f/bMExPdvp-2/pbau-tertius.svg" style="max-width: 100%;"></a>
</p>

Netdata metrics are [here](https://app.netdata.cloud/spaces/plumbum/rooms/validators/nodes/7ff41d8a-f1a6-423f-99e2-ceb55dd31039#chartName=menu_system&utc=America%2FNew_York)

```elixir
'''
Vl.new(width: 750, height: 400, title: "Uneven Peanut Swift HNT/USD")
|> Vl.data_from_values(ups_data)
|> Vl.encode_field(:x, "timestamp", 
                    type: :temporal,
                    time_unit: [
                      unit: "yearmonthdate",
                      step: 1
                      ],
                    title: "Date"
                  )  
|> Vl.layers([
  Vl.new()
  |> Vl.mark(:bar, color: "#6BC702", tooltip: true)
  |> Vl.encode_field(:y, "amount", 
                      type: :quantitative,
                      aggregate: :sum,
                      title: "HNT"),
  Vl.new()
  |> Vl.mark(:line)
  |> Vl.encode_field(:y, "price", 
                      type: :quantitative,
                      aggregate: :mean, 
                      title: "USD")
  |> Vl.encode(:size, value: 2)
])
|> Vl.resolve(:scale, y: :independent)
'''
```

```elixir
timestamp = "2021-07-12T01:20:13.000000Z"
{:ok, dt, _} = DateTime.from_iso8601(timestamp)
dt.to_string("%Y-%M")
```

```elixir
totals =
  val_data
  |> Enum.map(& &1)
```

```elixir
"""
### Summary for July and Aug (MTD)

| Validator | July (HNT)   | July avg (USD) | Aug (HNT)   | Aug avg (USD) |
|-----------|--------------|----------------|-------------|---------------|
#{Enum.each(totals, &"| #{&1["validator"]} | #{&1["july_hnt"]} | #{&1["july_usd"]} | #{&1["price"]} |\n")}

### Raw Results for July and Aug (MTD)

| Validator | Date | Amount (HNT) | Price (USD) |
|-----------|------|--------------|-------------| 
#{Enum.map(val_data, &"| #{&1["validator"]} | #{&1["timestamp"]} | #{&1["amount"]} | #{&1["price"]} |\n")}
"""
|> Kino.Markdown.new()
```

> add table, then persist the data....
